diff --git a/Makefile b/Makefile
index 6ba43fb..77a14ee 100644
--- a/Makefile
+++ b/Makefile
@@ -1,13 +1,14 @@
 #
 # Makefile for Linux CIFS VFS client 
 #
-obj-$(CONFIG_CIFS) += cifs.o
+obj-$(CONFIG_CIFS) += etercifs.o
 
-cifs-y := cifsfs.o cifssmb.o cifs_debug.o connect.o dir.o file.o inode.o \
+etercifs-y := cifsfs.o cifssmb.o cifs_debug.o connect.o dir.o file.o inode.o \
 	  link.o misc.o netmisc.o smbdes.o smbencrypt.o transport.o asn1.o \
 	  md4.o md5.o cifs_unicode.o nterr.o xattr.o cifsencrypt.o fcntl.o \
 	  readdir.o ioctl.o sess.o export.o cifsacl.o
 
-cifs-$(CONFIG_CIFS_UPCALL) += cifs_spnego.o
+etercifs-y += cifs_spnego.o
 
-cifs-$(CONFIG_CIFS_DFS_UPCALL) += dns_resolve.o cifs_dfs_ref.o
+etercifs-y += dns_resolve.o cifs_dfs_ref.o
+EXTRA_CFLAGS=-DCONFIG_CIFS_UPCALL=y -DCONFIG_CIFS_DFS_UPCALL=y
diff --git a/cifs_debug.c b/cifs_debug.c
index cc950f6..9ea3219 100644
--- a/cifs_debug.c
+++ b/cifs_debug.c
@@ -462,6 +462,8 @@ static read_proc_t experimEnabled_read;
 static write_proc_t experimEnabled_write;
 static read_proc_t linuxExtensionsEnabled_read;
 static write_proc_t linuxExtensionsEnabled_write;
+static read_proc_t etersoft_read;
+static write_proc_t etersoft_write;
 
 void
 cifs_proc_init(void)
@@ -526,6 +528,12 @@ cifs_proc_init(void)
 	if (pde)
 		pde->write_proc = lookupFlag_write;
 
+	pde =
+	create_proc_read_entry("Etersoft", 0, proc_fs_cifs,
+				etersoft_read, NULL);
+	if (pde)
+		pde->write_proc = etersoft_write;
+
 /*	pde =
 	    create_proc_read_entry("NTLMV2Enabled", 0, proc_fs_cifs,
 				ntlmv2_enabled_read, NULL);
@@ -559,6 +567,7 @@ cifs_proc_clean(void)
 	remove_proc_entry("LinuxExtensionsEnabled", proc_fs_cifs);
 	remove_proc_entry("Experimental", proc_fs_cifs);
 	remove_proc_entry("LookupCacheEnabled", proc_fs_cifs);
+	remove_proc_entry("Etersoft", proc_fs_cifs);
 	remove_proc_entry("fs/cifs", NULL);
 }
 
@@ -917,6 +926,44 @@ security_flags_write(struct file *file, const char __user *buffer,
 	/* BB should we turn on MAY flags for other MUST options? */
 	return count;
 }
+static int
+etersoft_read(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+	int len;
+
+	len = sprintf(page, "%d\n", etersoft_flag);
+
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+
+	return len;
+}
+static int
+etersoft_write(struct file *file, const char __user *buffer,
+		      unsigned long count, void *data)
+{
+	char c;
+	int rc;
+
+	rc = get_user(c, buffer);
+	if (rc)
+		return rc;
+	if (c == '0' || c == 'n' || c == 'N')
+		etersoft_flag = 0;
+	else if (c == '1' || c == 'y' || c == 'Y')
+		etersoft_flag = 1;
+
+	return count;
+}
 #else
 inline void cifs_proc_init(void)
 {
diff --git a/cifsfs.c b/cifsfs.c
index 5df93fd..1fabc42 100644
--- a/cifsfs.c
+++ b/cifsfs.c
@@ -35,6 +35,7 @@
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/freezer.h>
+#include <linux/version.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE
@@ -55,6 +55,7 @@ static struct quotactl_ops cifs_quotactl_ops;
 int cifsFYI = 0;
 int cifsERROR = 1;
 int traceSMB = 0;
+unsigned int etersoft_flag = 1;
 unsigned int oplockEnabled = 1;
 unsigned int experimEnabled = 0;
 unsigned int linuxExtEnabled = 1;
@@ -598,6 +599,19 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	return written;
 }
 
+static ssize_t cifs_file_read(struct file *file, char *user, size_t cnt, loff_t *pos)
+{
+	if( file!=NULL && file->f_dentry!=NULL && CIFS_I(file->f_dentry->d_inode)!=NULL ) {
+		int retval = 0;
+		CIFS_I(file->f_dentry->d_inode)->needForceInvalidate = 1;
+		retval = cifs_revalidate(file->f_dentry);
+		if( retval < 0 )
+			return (ssize_t)retval;
+	}
+
+	return do_sync_read(file,user,cnt,pos);
+}
+
 static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 {
 	/* origin == SEEK_END => we must revalidate the cached file length */
@@ -676,7 +690,7 @@ const struct inode_operations cifs_symlink_inode_ops = {
 };
 
 const struct file_operations cifs_file_ops = {
-	.read = do_sync_read,
+	.read = cifs_file_read,
 	.write = do_sync_write,
 	.aio_read = generic_file_aio_read,
 	.aio_write = cifs_file_aio_write,
@@ -766,7 +766,11 @@
 };
 
 static void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+cifs_init_once(struct kmem_cache *cachep, void *inode)
+#else
 cifs_init_once(void *inode)
+#endif
 {
 	struct cifsInodeInfo *cifsi = inode;
 
@@ -969,6 +983,10 @@ static int cifs_oplock_thread(void *dummyarg)
 				to server still is disconnected since oplock
 				already released by the server in that case */
 				if (pTcon->tidStatus != CifsNeedReconnect) {
+					/* PV: disable caching if oplock missed  */
+					CIFS_I(inode)->clientCanCacheRead = false;
+					CIFS_I(inode)->clientCanCacheAll = false;
+
 				    rc = CIFSSMBLock(0, pTcon, netfid,
 					    0 /* len */ , 0 /* offset */, 0,
 					    0, LOCKING_ANDX_OPLOCK_RELEASE,
diff --git a/cifsglob.h b/cifsglob.h
index 9cfcf32..3a568f9 100644
--- a/cifsglob.h
+++ b/cifsglob.h
@@ -351,6 +351,7 @@ struct cifsInodeInfo {
 	bool clientCanCacheRead:1;	/* read oplock */
 	bool clientCanCacheAll:1;	/* read and writebehind oplock */
 	bool oplockPending:1;
+	unsigned needForceInvalidate:1; 
 	struct inode vfs_inode;
 };
 
@@ -635,6 +636,8 @@ GLOBAL_EXTERN atomic_t smBufAllocCount;
 GLOBAL_EXTERN atomic_t midCount;
 
 /* Misc globals */
+GLOBAL_EXTERN unsigned int etersoft_flag; /* if enabled allows extended shared modes in open */
+
 GLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions
 				to be established on existing mount if we
 				have the uid/password or Kerberos credential
diff --git a/cifsproto.h b/cifsproto.h
index b9f5e93..f00de5c 100644
--- a/cifsproto.h
+++ b/cifsproto.h
@@ -247,7 +247,7 @@ extern int CIFSSMBQueryReparseLinkInfo(const int xid,
 
 extern int CIFSSMBOpen(const int xid, struct cifsTconInfo *tcon,
 			const char *fileName, const int disposition,
-			const int access_flags, const int omode,
+			const int access_flags, const int share_flags, const int omode,
 			__u16 *netfid, int *pOplock, FILE_ALL_INFO *,
 			const struct nls_table *nls_codepage, int remap);
 extern int SMBLegacyOpen(const int xid, struct cifsTconInfo *tcon,
diff --git a/cifssmb.c b/cifssmb.c
index 174bf8a..4dd70f1 100644
--- a/cifssmb.c
+++ b/cifssmb.c
@@ -1228,6 +1228,11 @@ SMBLegacyOpen(const int xid, struct cifsTconInfo *tcon,
 	int name_len;
 	__u16 count;
 
+	if (etersoft_flag) {
+		printk("Etersoft: Do not use SMBLegacyOpen!\n");
+		return rc;
+	}
+
 OldOpenRetry:
 	rc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,
 		      (void **) &pSMBr);
@@ -1323,7 +1328,7 @@ OldOpenRetry:
 int
 CIFSSMBOpen(const int xid, struct cifsTconInfo *tcon,
 	    const char *fileName, const int openDisposition,
-	    const int access_flags, const int create_options, __u16 *netfid,
+	    const int access_flags, const int share_flags, const int create_options, __u16 *netfid,
 	    int *pOplock, FILE_ALL_INFO *pfile_info,
 	    const struct nls_table *nls_codepage, int remap)
 {
@@ -1380,7 +1385,7 @@ openRetry:
 	if (create_options & CREATE_OPTION_READONLY)
 		pSMB->FileAttributes |= cpu_to_le32(ATTR_READONLY);
 
-	pSMB->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);
+	pSMB->ShareAccess = cpu_to_le32(share_flags);
 	pSMB->CreateDisposition = cpu_to_le32(openDisposition);
 	pSMB->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);
 	/* BB Expirement with various impersonation levels and verify */
diff --git a/connect.c b/connect.c
index d49e274..1302d85 100644
--- a/connect.c
+++ b/connect.c
@@ -35,6 +35,7 @@
 #include <linux/freezer.h>
 #include <asm/uaccess.h>
 #include <asm/processor.h>
+#include <linux/autoconf.h>
 #include "cifspdu.h"
 #include "cifsglob.h"
 #include "cifsproto.h"
diff --git a/dir.c b/dir.c
index fb69c1f..90ddab3 100644
--- a/dir.c
+++ b/dir.c
@@ -207,7 +207,7 @@ cifs_create(struct inode *inode, struct dentry *direntry, int mode,
 
 	if (cifs_sb->tcon->ses->capabilities & CAP_NT_SMBS)
 		rc = CIFSSMBOpen(xid, pTcon, full_path, disposition,
-			 desiredAccess, create_options,
+			 desiredAccess, FILE_SHARE_ALL, create_options,
 			 &fileHandle, &oplock, buf, cifs_sb->local_nls,
 			 cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);
 	else
@@ -404,6 +404,7 @@ int cifs_mknod(struct inode *inode, struct dentry *direntry, int mode,
 					  WRITE_OWNER | WRITE_DAC be better? */,
 					 /* Create a file and set the
 					    file attribute to SYSTEM */
+					 FILE_SHARE_ALL,
 					 CREATE_NOT_DIR | CREATE_OPTION_SPECIAL,
 					 &fileHandle, &oplock, buf,
 					 cifs_sb->local_nls,
diff --git a/fcntl.c b/fcntl.c
index 5a57581..9dc88ca 100644
--- a/fcntl.c
+++ b/fcntl.c
@@ -89,7 +89,7 @@ int cifs_dir_notify(struct file *file, unsigned long arg)
 	} else {
 		cFYI(1, ("dir notify on file %s Arg 0x%lx", full_path, arg));
 		rc = CIFSSMBOpen(xid, pTcon, full_path, FILE_OPEN,
-			GENERIC_READ | SYNCHRONIZE, 0 /* create options */,
+			GENERIC_READ | SYNCHRONIZE, FILE_SHARE_ALL, 0 /* create options */,
 			&netfid, &oplock, NULL, cifs_sb->local_nls,
 			cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);
 		/* BB fixme - add this handle to a notify handle list */
diff --git a/file.c b/file.c
index 0aac824..7fe313e 100644
--- a/file.c
+++ b/file.c
@@ -95,6 +95,15 @@ static inline int cifs_get_disposition(unsigned int flags)
 	else
 		return FILE_OPEN;
 }
+ 
+static inline int cifs_get_share_flags(unsigned int flags)
+{
+	if (!etersoft_flag)
+		return FILE_SHARE_ALL;
+	return ((~(flags>>29))&7);
+}
+
+
 
 /* all arguments to this function must be checked for validity in caller */
 static inline int cifs_open_inode_helper(struct inode *inode, struct file *file,
@@ -173,6 +182,7 @@ int cifs_open(struct inode *inode, struct file *file)
 	struct list_head *tmp;
 	char *full_path = NULL;
 	int desiredAccess;
+	int desiredShare;
 	int disposition;
 	__u16 netfid;
 	FILE_ALL_INFO *buf = NULL;
@@ -221,6 +231,7 @@ int cifs_open(struct inode *inode, struct file *file)
 	cFYI(1, ("inode = 0x%p file flags are 0x%x for %s",
 		 inode, file->f_flags, full_path));
 	desiredAccess = cifs_convert_flags(file->f_flags);
+	desiredShare = cifs_get_share_flags(file->f_flags);
 
 /*********************************************************************
  *  open flag mapping table:
@@ -270,7 +281,7 @@ int cifs_open(struct inode *inode, struct file *file)
 
 	if (cifs_sb->tcon->ses->capabilities & CAP_NT_SMBS)
 		rc = CIFSSMBOpen(xid, pTcon, full_path, disposition,
-			 desiredAccess, CREATE_NOT_DIR, &netfid, &oplock, buf,
+			 desiredAccess, desiredShare, CREATE_NOT_DIR, &netfid, &oplock, buf,
 			 cifs_sb->local_nls, cifs_sb->mnt_cifs_flags
 				 & CIFS_MOUNT_MAP_SPECIAL_CHR);
 	else
@@ -354,6 +365,7 @@ static int cifs_reopen_file(struct file *file, bool can_flush)
 	struct inode *inode;
 	char *full_path = NULL;
 	int desiredAccess;
+	int desiredShare;
 	int disposition = FILE_OPEN;
 	__u16 netfid;
 
@@ -404,6 +416,7 @@ reopen_error_exit:
 	cFYI(1, ("inode = 0x%p file flags 0x%x for %s",
 		 inode, file->f_flags, full_path));
 	desiredAccess = cifs_convert_flags(file->f_flags);
+	desiredShare = cifs_get_share_flags(file->f_flags);
 
 	if (oplockEnabled)
 		oplock = REQ_OPLOCK;
@@ -416,7 +429,7 @@ reopen_error_exit:
 	   and server version of file size can be stale. If we knew for sure
 	   that inode was not dirty locally we could do this */
 
-	rc = CIFSSMBOpen(xid, pTcon, full_path, disposition, desiredAccess,
+	rc = CIFSSMBOpen(xid, pTcon, full_path, disposition, desiredAccess, desiredShare,
 			 CREATE_NOT_DIR, &netfid, &oplock, NULL,
 			 cifs_sb->local_nls, cifs_sb->mnt_cifs_flags &
 				CIFS_MOUNT_MAP_SPECIAL_CHR);
diff --git a/inode.c b/inode.c
index 722be54..557068d 100644
--- a/inode.c
+++ b/inode.c
@@ -21,6 +21,7 @@
 #include <linux/fs.h>
 #include <linux/stat.h>
 #include <linux/pagemap.h>
+#include <linux/version.h>
 #include <asm/div64.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
@@ -29,6 +30,45 @@
 #include "cifs_debug.h"
 #include "cifs_fs_sb.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+static inline void zero_user_segments(struct page *page,
+	unsigned start1, unsigned end1,
+	unsigned start2, unsigned end2)
+{
+	void *kaddr = kmap_atomic(page, KM_USER0);
+
+	BUG_ON(end1 > PAGE_SIZE ||
+		end2 > PAGE_SIZE);
+
+	if (end1 > start1)
+		memset(kaddr + start1, 0, end1 - start1);
+
+	if (end2 > start2)
+		memset(kaddr + start2, 0, end2 - start2);
+
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+
+static inline void zero_user_segment(struct page *page,
+	unsigned start, unsigned end)
+{
+	zero_user_segments(page, start, end, 0, 0);
+}
+
+static inline void zero_user(struct page *page,
+	unsigned start, unsigned size)
+{
+	zero_user_segments(page, start, start + size, 0, 0);
+}
+
+static inline void iget_failed(struct inode *inode)
+{
+       make_bad_inode(inode);
+       unlock_new_inode(inode);
+       iput(inode);
+}
+#endif
 
 static void cifs_set_ops(struct inode *inode, const bool is_dfs_referral)
 {
@@ -294,7 +334,7 @@ static int decode_sfu_inode(struct inode *inode, __u64 size,
 		return -EINVAL;	 /* EOPNOTSUPP? */
 	}
 
-	rc = CIFSSMBOpen(xid, pTcon, path, FILE_OPEN, GENERIC_READ,
+	rc = CIFSSMBOpen(xid, pTcon, path, FILE_OPEN, GENERIC_READ, FILE_SHARE_ALL,
 			 CREATE_NOT_DIR, &netfid, &oplock, NULL,
 			 cifs_sb->local_nls,
 			 cifs_sb->mnt_cifs_flags &
@@ -716,8 +756,8 @@ psx_del_no_retry:
 		int oplock = 0;
 		__u16 netfid;
 
-		rc = CIFSSMBOpen(xid, pTcon, full_path, FILE_OPEN, DELETE,
-				 CREATE_NOT_DIR | CREATE_DELETE_ON_CLOSE,
+		rc = CIFSSMBOpen(xid, pTcon, full_path, FILE_OPEN, DELETE, FILE_SHARE_ALL,
+				 CREATE_NOT_DIR | CREATE_DELETE_ON_CLOSE, 
 				 &netfid, &oplock, NULL, cifs_sb->local_nls,
 				 cifs_sb->mnt_cifs_flags &
 					CIFS_MOUNT_MAP_SPECIAL_CHR);
@@ -760,8 +800,7 @@ psx_del_no_retry:
 			/* BB could scan to see if we already have it open
 			   and pass in pid of opener to function */
 				rc = CIFSSMBOpen(xid, pTcon, full_path,
-						 FILE_OPEN, SYNCHRONIZE |
-						 FILE_WRITE_ATTRIBUTES, 0,
+						 FILE_OPEN, SYNCHRONIZE | FILE_WRITE_ATTRIBUTES, FILE_SHARE_ALL, 0,
 						 &netfid, &oplock, NULL,
 						 cifs_sb->local_nls,
 						 cifs_sb->mnt_cifs_flags &
@@ -788,7 +827,7 @@ psx_del_no_retry:
 				__u16 netfid;
 
 				rc = CIFSSMBOpen(xid, pTcon, full_path,
-						 FILE_OPEN, DELETE,
+						 FILE_OPEN, DELETE, FILE_SHARE_ALL,
 						 CREATE_NOT_DIR |
 						 CREATE_DELETE_ON_CLOSE,
 						 &netfid, &oplock, NULL,
@@ -1176,7 +1215,7 @@ int cifs_rename(struct inode *source_inode, struct dentry *source_direntry,
 		/* if renaming directory - we should not say CREATE_NOT_DIR,
 		   need to test renaming open directory, also GENERIC_READ
 		   might not right be right access to request */
-		rc = CIFSSMBOpen(xid, pTcon, fromName, FILE_OPEN, GENERIC_READ,
+		rc = CIFSSMBOpen(xid, pTcon, fromName, FILE_OPEN, GENERIC_READ, FILE_SHARE_ALL, 
 				 CREATE_NOT_DIR, &netfid, &oplock, NULL,
 				 cifs_sb_source->local_nls,
 				 cifs_sb_source->mnt_cifs_flags &
@@ -1236,7 +1275,7 @@ int cifs_revalidate(struct dentry *direntry)
 		 direntry->d_inode->i_count.counter, direntry,
 		 direntry->d_time, jiffies));
 
-	if (cifsInode->time == 0) {
+	if (cifsInode->time == 0 || cifsInode->needForceInvalidate ) {
 		/* was set to zero previously to force revalidate */
 	} else if (time_before(jiffies, cifsInode->time + HZ) &&
 		   lookupCacheEnabled) {
@@ -1680,7 +1719,7 @@ int cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 			/* BB we could scan to see if we already have it open
 			   and pass in pid of opener to function */
 			rc = CIFSSMBOpen(xid, pTcon, full_path, FILE_OPEN,
-					 SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
+					 SYNCHRONIZE | FILE_WRITE_ATTRIBUTES, FILE_SHARE_ALL,
 					 CREATE_NOT_DIR, &netfid, &oplock,
 					 NULL, cifs_sb->local_nls,
 					 cifs_sb->mnt_cifs_flags &
diff --git a/link.c b/link.c
index 63f6440..7c9f495 100644
--- a/link.c
+++ b/link.c
@@ -279,7 +279,7 @@ cifs_readlink(struct dentry *direntry, char __user *pBuffer, int buflen)
 		cERROR(1, ("SFU style symlinks not implemented yet"));
 		/* add open and read as in fs/cifs/inode.c */
 	} else {
-		rc = CIFSSMBOpen(xid, pTcon, full_path, FILE_OPEN, GENERIC_READ,
+		rc = CIFSSMBOpen(xid, pTcon, full_path, FILE_OPEN, GENERIC_READ, FILE_SHARE_ALL,
 				OPEN_REPARSE_POINT, &fid, &oplock, NULL,
 				cifs_sb->local_nls,
 				cifs_sb->mnt_cifs_flags &
diff -Nu old/cifsacl.c new/cifsacl.c
--- old/cifsacl.c	2008-06-02 18:29:25 +0400
+++ new/cifsacl.c	2008-07-30 21:18:59 +0400
@@ -592,7 +592,7 @@
 		int oplock = 0;
 		/* open file */
 		rc = CIFSSMBOpen(xid, cifs_sb->tcon, path, FILE_OPEN,
-				READ_CONTROL, 0, &fid, &oplock, NULL,
+				READ_CONTROL, FILE_SHARE_ALL, 0, &fid, &oplock, NULL,
 				cifs_sb->local_nls, cifs_sb->mnt_cifs_flags &
 					CIFS_MOUNT_MAP_SPECIAL_CHR);
 		if (rc != 0) {
@@ -646,7 +646,7 @@
 		int oplock = 0;
 		/* open file */
 		rc = CIFSSMBOpen(xid, cifs_sb->tcon, path, FILE_OPEN,
-				WRITE_DAC, 0, &fid, &oplock, NULL,
+				WRITE_DAC, FILE_SHARE_ALL, 0, &fid, &oplock, NULL,
 				cifs_sb->local_nls, cifs_sb->mnt_cifs_flags &
 					CIFS_MOUNT_MAP_SPECIAL_CHR);
 		if (rc != 0) {
diff -Nu old/xattr.c new/xattr.c
--- old/xattr.c	2008-07-30 21:04:27 +0400
+++ new/xattr.c	2008-07-30 21:04:08 +0400
@@ -269,7 +269,7 @@
 			__u32 buflen = 0;
 			if (experimEnabled)
 				rc = CIFSSMBOpen(xid, pTcon, full_path,
-					FILE_OPEN, GENERIC_READ, 0, &fid,
+					FILE_OPEN, GENERIC_READ, FILE_SHARE_ALL, 0, &fid,
 					&oplock, NULL, cifs_sb->local_nls,
 					cifs_sb->mnt_cifs_flags &
 					CIFS_MOUNT_MAP_SPECIAL_CHR);
